#include "main.h"

#include <stdio.h>
#include <stdlib.h>

#include "gba.h"

#include "images/titleScreen.h"
#include "images/sprite.h"
#include "images/winScreen.h"
/* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:
// #include "images/garbage.h"

/* TODO: */
// Add any additional states you need for your app. You are not requried to use
// these specific provided states.
enum gba_state {
  START,
  PLAY,
  WIN,
  LOSE,
  BUILDGAME,
  BUILDLEVEL,
};

int main(void) {
  /* TODO: */
  // Manipulate REG_DISPCNT here to set Mode 3. //
  REG_DISPCNT = MODE3 | BG2_ENABLE;
  // Save current and previous state of button input.
  u32 previousButtons = BUTTONS;
  u32 currentButtons = BUTTONS;


  // Load initial application state
  enum gba_state state = BUILDGAME;

  while (1) {
    currentButtons = BUTTONS; // Load the current state of the buttons

    /* TODO: */
    // Manipulate the state machine below as needed //
    // NOTE: Call waitForVBlank() before you draw

    switch (state) {
      case BUILDGAME:
        waitForVBlank();
        drawFullScreenImageDMA(titleScreen);
        waitForVBlank();
        drawCenteredString(20, 120, 0, 0, "WORLD'S HARDEST GAME", WHITE);
        drawCenteredString(140, 120, 0, 0, "PRESS START", WHITE);
        static int numFails = 0;
        state = START;
        break;
      case START:
        if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons)) {
          state = BUILDLEVEL;
        }
        if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
          state = BUILDGAME;
          continue;
        }
        break;
      case BUILDLEVEL:
        //Draw the map
        waitForVBlank();
        drawRectDMA(0, 0, 240, 160, BACKGROUND);
        drawCenteredString(25, 80, 0, 0, "LEVEL 1", WHITE);
        drawCenteredString(135, 120, 0, 0, "GOOD LUCK!", WHITE);
        //Borders
        waitForVBlank();
        drawRectDMA(44, 39, 1, 72, BLACK);
        drawRectDMA(44, 200, 1, 72, BLACK);
        drawRectDMA(45, 70, 1, 60, BLACK);
        drawRectDMA(55, 169, 1, 60, BLACK);
        drawRectDMA(44, 40, 31, 1, BLACK);
        drawRectDMA(115, 169, 31, 1, BLACK);
        drawRectDMA(115, 40, 50, 1, BLACK);
        drawRectDMA(44, 150, 50, 1, BLACK);
        drawRectDMA(106, 90, 1, 10, BLACK);
        drawRectDMA(44, 149, 1, 10, BLACK);
        drawRectDMA(105, 90, 70, 1, BLACK);
        drawRectDMA(54, 80, 70, 1, BLACK);
        drawRectDMA(56, 160, 1, 50, BLACK);
        drawRectDMA(54, 79, 1, 50, BLACK);
        drawRectDMA(55, 160, 9, 1, BLACK);
        drawRectDMA(104, 71, 9, 1, BLACK);
        //Winzones
        drawRectDMA(45, 40, 30, 70, LIGHTGREEN);
        drawRectDMA(45, 170, 30, 70, LIGHTGREEN);
        //Map lattice
        waitForVBlank();
        drawRectDMA(105, 70, 10, 10, WHITE);
        drawRectDMA(105, 80, 10, 10, LIGHTGRAY);
        drawRectDMA(45, 150, 10, 10, WHITE);
        drawRectDMA(45, 160, 10, 10, LIGHTGRAY);
        for (int i = 0; i < 5; i++) {
          for (int j = 0; j < 8; j++) {
            if ((i + j) % 2 == 0) {
              drawRectDMA(55 + 10*i, 80 + 10*j, 10, 10, WHITE);
            } else {
              drawRectDMA(55 + 10*i, 80 + 10*j, 10, 10, LIGHTGRAY);
            }
          }
        }

        //Instantiate objects
        static struct player p1;
        p1.row = 61;
        p1.col = 51;
        for (int r = 0; r < SPRITE_HEIGHT; r++) {
          for (int c = 0; c < SPRITE_WIDTH; c++) {
            p1.previousBackground[OFFSET(r, c, SPRITE_WIDTH)] = videoBuffer[OFFSET(r + p1.row, c + p1.col, WIDTH)];
          }
        }

        static struct enemy enemies[5];
        for (int i = 0; i < 5; i++) {
          enemies[i].row = 57 + 10*i;
          enemies[i].col = 117;
          if (i % 2 == 0) {
            enemies[i].velocity = -1;
          } else {
            enemies[i].velocity = 1;
          }
          for (int r = 0; r < 6; r++) {
            for (int c = 0; c < 6; c++) {
              enemies[i].previousBackground[OFFSET(r, c, 6)] = videoBuffer[OFFSET(r + enemies[i].row, c + enemies[i].col, WIDTH)];
            }
          }
        }
        state = PLAY;
      break;
      case PLAY:
        //Redraw over previous positions
        waitForVBlank();
        for (int r = 0; r < SPRITE_HEIGHT; r++) {
          for (int c = 0; c < SPRITE_WIDTH; c++) {
            setPixel(r + p1.row, c + p1.col, p1.previousBackground[OFFSET(r, c, SPRITE_WIDTH)]);
          }
        }
        for (int i = 0; i < 5; i++) {
          for (int r = 0; r < 6; r++) {
            for (int c = 0; c < 6; c++) {
              setPixel(r + enemies[i].row, c + enemies[i].col, enemies[i].previousBackground[OFFSET(r, c, 6)]);
            }
          }
        }

        //check different buttons
        if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
          state = BUILDGAME;
          continue;
        }
        //collision detection and movement of the player
        int collide;
        if (KEY_DOWN(BUTTON_UP, currentButtons)) {
          collide = 0;
          for (int c = p1.col; c < p1.col + SPRITE_WIDTH; c++) {
            if (videoBuffer[OFFSET(p1.row - 1, c, WIDTH)] - BLACK == 0) {
              collide = 1;
              break;
            }
          }
          if (collide == 0) {
            p1.row--;
          }
        }
        if (KEY_DOWN(BUTTON_DOWN, currentButtons)) {
          collide = 0;
          for (int c = p1.col; c < p1.col + SPRITE_WIDTH; c++) {
            if (videoBuffer[OFFSET(p1.row + SPRITE_HEIGHT, c, WIDTH)] - BLACK == 0) {
              collide = 1;
              break;
            }
          }
          if (collide == 0) {
            p1.row++;
          }
        }
        if (KEY_DOWN(BUTTON_RIGHT, currentButtons)) {
          collide = 0;
          for (int r = p1.row; r < p1.row + SPRITE_HEIGHT; r++) {
            if (videoBuffer[OFFSET(r, p1.col + SPRITE_WIDTH, WIDTH)] - BLACK == 0) {
              collide = 1;
              break;
            }
          }
          if (collide == 0) {
            p1.col++;
          }
        }
        if (KEY_DOWN(BUTTON_LEFT, currentButtons)) {
          collide = 0;
          for (int r = p1.row; r < p1.row + SPRITE_HEIGHT; r++) {
            if (videoBuffer[OFFSET(r, p1.col - 1, WIDTH)] - BLACK == 0) {
              collide = 1;
              break;
            }
          }
          if (collide == 0) {
            p1.col--;
          }
        }
        //calculating and drawing movement of the enemies
        for (int i = 0; i < 5; i++) {
          if (videoBuffer[OFFSET(enemies[i].row, enemies[i].col - 1, WIDTH)] - BLACK != 0 && videoBuffer[OFFSET(enemies[i].row, enemies[i].col + 6, WIDTH)] - BLACK != 0) {
            enemies[i].col = enemies[i].col + enemies[i].velocity;
          } else {
            enemies[i].velocity = -enemies[i].velocity;
            enemies[i].col = enemies[i].col + enemies[i].velocity;
          }
          for (int r = 0; r < 6; r++) {
            for (int c = 0; c < 6; c++) {
              enemies[i].previousBackground[OFFSET(r, c, 6)] = videoBuffer[OFFSET(r + enemies[i].row, c + enemies[i].col, WIDTH)];
            }
          }
          drawRectDMA(enemies[i].row, enemies[i].col, 6, 6, RED);
        }
        //updating the players previous position and determining win or loss conditions
        for (int r = 0; r < SPRITE_HEIGHT; r++) {
          for (int c = 0; c < SPRITE_WIDTH; c++) {
            p1.previousBackground[OFFSET(r, c, SPRITE_WIDTH)] = videoBuffer[OFFSET(r + p1.row, c + p1.col, WIDTH)];
            if (videoBuffer[OFFSET(r + p1.row, c + p1.col, WIDTH)] - RED == 0) {
              state = LOSE;
            }
            if (p1.col > 175 && videoBuffer[OFFSET(r + p1.row, c + p1.col, WIDTH)] - LIGHTGREEN == 0) {
              state = WIN;
            }
          }
        }

        //drawing new position of player and fails
        drawImageDMA(p1.row, p1.col, SPRITE_WIDTH, SPRITE_HEIGHT, sprite);
        char fails[11];
        sprintf(fails, "FAILS: %d", numFails);
        drawCenteredString(25, 160, 0, 0, fails, WHITE);
        break;
      case WIN:
        if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
          state = BUILDGAME;
          continue;
        }
        waitForVBlank();
        drawFullScreenImageDMA(winScreen);
        char winMessage[32];
        sprintf(winMessage, "YOU WON AFTER FAILING %d TIMES!", numFails);
        drawCenteredString(25, 120, 0, 0, winMessage, BLACK);
        drawCenteredString(120, 120, 0, 0, "PRESS START TO TRY AGAIN", BLACK);
        drawCenteredString(140, 120, 0, 0, "PRESS SELECT FOR THE MAIN MENU", BLACK);
        numFails = 0;
        state = START;
        break;
      case LOSE:
        state = BUILDLEVEL;
        numFails++;
        break;
    }

    previousButtons = currentButtons; // Store the current state of the buttons
  }
  return 0;
}
